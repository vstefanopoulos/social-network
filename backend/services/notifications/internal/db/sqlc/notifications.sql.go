// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notifications.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createNotification = `-- name: CreateNotification :one
INSERT INTO notifications (
    user_id,
    notif_type,
    source_service,
    source_entity_id,
    needs_action,
    acted,
    payload,
    created_at,
    expires_at,
    count
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, NOW(), $8, $9
) RETURNING id, user_id, notif_type, source_service, source_entity_id, seen, needs_action, acted, payload, created_at, expires_at, deleted_at, count
`

type CreateNotificationParams struct {
	UserID         int64
	NotifType      string
	SourceService  string
	SourceEntityID pgtype.Int8
	NeedsAction    pgtype.Bool
	Acted          pgtype.Bool
	Payload        []byte
	ExpiresAt      pgtype.Timestamptz
	Count          pgtype.Int4
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createNotification,
		arg.UserID,
		arg.NotifType,
		arg.SourceService,
		arg.SourceEntityID,
		arg.NeedsAction,
		arg.Acted,
		arg.Payload,
		arg.ExpiresAt,
		arg.Count,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.NotifType,
		&i.SourceService,
		&i.SourceEntityID,
		&i.Seen,
		&i.NeedsAction,
		&i.Acted,
		&i.Payload,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.DeletedAt,
		&i.Count,
	)
	return i, err
}

const createNotificationType = `-- name: CreateNotificationType :exec
INSERT INTO notification_types (notif_type, category, default_enabled)
VALUES ($1, $2, $3)
ON CONFLICT (notif_type) DO NOTHING
`

type CreateNotificationTypeParams struct {
	NotifType      string
	Category       pgtype.Text
	DefaultEnabled pgtype.Bool
}

func (q *Queries) CreateNotificationType(ctx context.Context, arg CreateNotificationTypeParams) error {
	_, err := q.db.Exec(ctx, createNotificationType, arg.NotifType, arg.Category, arg.DefaultEnabled)
	return err
}

const deleteNotification = `-- name: DeleteNotification :exec
UPDATE notifications SET deleted_at = NOW() WHERE id = $1 AND user_id = $2
`

type DeleteNotificationParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) DeleteNotification(ctx context.Context, arg DeleteNotificationParams) error {
	_, err := q.db.Exec(ctx, deleteNotification, arg.ID, arg.UserID)
	return err
}

const getNotificationByID = `-- name: GetNotificationByID :one
SELECT id, user_id, notif_type, source_service, source_entity_id, seen, needs_action, acted, payload, created_at, expires_at, deleted_at, count
FROM notifications
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetNotificationByID(ctx context.Context, id int64) (Notification, error) {
	row := q.db.QueryRow(ctx, getNotificationByID, id)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.NotifType,
		&i.SourceService,
		&i.SourceEntityID,
		&i.Seen,
		&i.NeedsAction,
		&i.Acted,
		&i.Payload,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.DeletedAt,
		&i.Count,
	)
	return i, err
}

const getNotificationByTypeAndEntity = `-- name: GetNotificationByTypeAndEntity :one
SELECT id, user_id, notif_type, source_service, source_entity_id, seen, needs_action, acted, payload, created_at, expires_at, deleted_at, count
FROM notifications
WHERE user_id = $1 AND notif_type = $2 AND source_entity_id = $3 AND deleted_at IS NULL
LIMIT 1
`

type GetNotificationByTypeAndEntityParams struct {
	UserID         int64
	NotifType      string
	SourceEntityID pgtype.Int8
}

func (q *Queries) GetNotificationByTypeAndEntity(ctx context.Context, arg GetNotificationByTypeAndEntityParams) (Notification, error) {
	row := q.db.QueryRow(ctx, getNotificationByTypeAndEntity, arg.UserID, arg.NotifType, arg.SourceEntityID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.NotifType,
		&i.SourceService,
		&i.SourceEntityID,
		&i.Seen,
		&i.NeedsAction,
		&i.Acted,
		&i.Payload,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.DeletedAt,
		&i.Count,
	)
	return i, err
}

const getNotificationType = `-- name: GetNotificationType :one
SELECT notif_type, category, default_enabled
FROM notification_types
WHERE notif_type = $1
`

func (q *Queries) GetNotificationType(ctx context.Context, notifType string) (NotificationType, error) {
	row := q.db.QueryRow(ctx, getNotificationType, notifType)
	var i NotificationType
	err := row.Scan(&i.NotifType, &i.Category, &i.DefaultEnabled)
	return i, err
}

const getUnreadNotificationByTypeAndEntity = `-- name: GetUnreadNotificationByTypeAndEntity :one
SELECT id, user_id, notif_type, source_service, source_entity_id, seen, needs_action, acted, payload, created_at, expires_at, deleted_at, count
FROM notifications
WHERE user_id = $1 AND notif_type = $2 AND source_entity_id = $3 AND seen = false AND deleted_at IS NULL
LIMIT 1
`

type GetUnreadNotificationByTypeAndEntityParams struct {
	UserID         int64
	NotifType      string
	SourceEntityID pgtype.Int8
}

func (q *Queries) GetUnreadNotificationByTypeAndEntity(ctx context.Context, arg GetUnreadNotificationByTypeAndEntityParams) (Notification, error) {
	row := q.db.QueryRow(ctx, getUnreadNotificationByTypeAndEntity, arg.UserID, arg.NotifType, arg.SourceEntityID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.NotifType,
		&i.SourceService,
		&i.SourceEntityID,
		&i.Seen,
		&i.NeedsAction,
		&i.Acted,
		&i.Payload,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.DeletedAt,
		&i.Count,
	)
	return i, err
}

const getUserNotifications = `-- name: GetUserNotifications :many
SELECT id, user_id, notif_type, source_service, source_entity_id, seen, needs_action, acted, payload, created_at, expires_at, deleted_at, count
FROM notifications
WHERE user_id = $1
  AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserNotificationsParams struct {
	UserID int64
	Limit  int32
	Offset int32
}

func (q *Queries) GetUserNotifications(ctx context.Context, arg GetUserNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getUserNotifications, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NotifType,
			&i.SourceService,
			&i.SourceEntityID,
			&i.Seen,
			&i.NeedsAction,
			&i.Acted,
			&i.Payload,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.DeletedAt,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserNotificationsCount = `-- name: GetUserNotificationsCount :one
SELECT COUNT(*)
FROM notifications
WHERE user_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUserNotificationsCount(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserNotificationsCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserUnreadNotificationsCount = `-- name: GetUserUnreadNotificationsCount :one
SELECT COUNT(*)
FROM notifications
WHERE user_id = $1 AND seen = false AND deleted_at IS NULL
`

func (q *Queries) GetUserUnreadNotificationsCount(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserUnreadNotificationsCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const markAllAsRead = `-- name: MarkAllAsRead :exec
UPDATE notifications SET seen = true WHERE user_id = $1 AND seen = false
`

func (q *Queries) MarkAllAsRead(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, markAllAsRead, userID)
	return err
}

const markNotificationAsActed = `-- name: MarkNotificationAsActed :exec
UPDATE notifications SET acted = true WHERE id = $1 AND user_id = $2
`

type MarkNotificationAsActedParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) MarkNotificationAsActed(ctx context.Context, arg MarkNotificationAsActedParams) error {
	_, err := q.db.Exec(ctx, markNotificationAsActed, arg.ID, arg.UserID)
	return err
}

const markNotificationAsRead = `-- name: MarkNotificationAsRead :exec
UPDATE notifications SET seen = true WHERE id = $1 AND user_id = $2
`

type MarkNotificationAsReadParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) MarkNotificationAsRead(ctx context.Context, arg MarkNotificationAsReadParams) error {
	_, err := q.db.Exec(ctx, markNotificationAsRead, arg.ID, arg.UserID)
	return err
}

const updateNotificationCount = `-- name: UpdateNotificationCount :exec
UPDATE notifications SET count = $1 WHERE id = $2 AND user_id = $3
`

type UpdateNotificationCountParams struct {
	Count  pgtype.Int4
	ID     int64
	UserID int64
}

func (q *Queries) UpdateNotificationCount(ctx context.Context, arg UpdateNotificationCountParams) error {
	_, err := q.db.Exec(ctx, updateNotificationCount, arg.Count, arg.ID, arg.UserID)
	return err
}
